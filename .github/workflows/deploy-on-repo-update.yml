name: Deploy on Repo Update

on:
  repository_dispatch:
    types: [repo-updated]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout infrastructure repo
        uses: actions/checkout@v4

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Parse webhook payload
        id: payload
        run: |
          REPO_NAME=$(echo '${{ github.event.client_payload.repo_name }}' | sed 's/.*\///')
          ENVIRONMENT='${{ github.event.client_payload.environment }}'
          BRANCH='${{ github.event.client_payload.branch }}'
          COMMIT_SHA='${{ github.event.client_payload.commit_sha }}'
          
          echo "repo_name=$REPO_NAME" >> $GITHUB_OUTPUT
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          
          echo "ðŸ“¦ Deploying $REPO_NAME ($ENVIRONMENT) from branch $BRANCH"

      - name: Find target servers
        id: servers
        run: |
          source ./scripts/parse-infrastructure-config.sh
          
          REPO_NAME="${{ steps.payload.outputs.repo_name }}"
          ENVIRONMENT="${{ steps.payload.outputs.environment }}"
          
          # Get servers for this repo/environment as JSON array
          SERVERS=$(yq eval ".servers | to_entries | .[] | select(.value.repos[] | .name == \"$REPO_NAME\" and .environment == \"$ENVIRONMENT\") | .key" infrastructure-config.yml | tr '\n' ' ')
          
          echo "servers=$SERVERS" >> $GITHUB_OUTPUT
          echo "Found servers: $SERVERS"

      - name: Deploy to each server
        env:
          REPO_NAME: ${{ steps.payload.outputs.repo_name }}
          ENVIRONMENT: ${{ steps.payload.outputs.environment }}
          BRANCH: ${{ steps.payload.outputs.branch }}
          COMMIT_SHA: ${{ steps.payload.outputs.commit_sha }}
          # Pass all potential SSH keys - workflow will use the correct one per server
          MAC_MINI_SSH: ${{ secrets.MAC_MINI_SSH }}
          EC2_SSH: ${{ secrets.EC2_SSH }}
          SERVER2_SSH: ${{ secrets.SERVER2_SSH }}
          # Pass all potential env vars
          FACTIII_STAGING_ENVS: ${{ secrets.FACTIII_STAGING_ENVS }}
          FACTIII_PROD_ENVS: ${{ secrets.FACTIII_PROD_ENVS }}
          CHOPSHOP_STAGING_ENVS: ${{ secrets.CHOPSHOP_STAGING_ENVS }}
          CHOPSHOP_PROD_ENVS: ${{ secrets.CHOPSHOP_PROD_ENVS }}
          LINK3D_STAGING_ENVS: ${{ secrets.LINK3D_STAGING_ENVS }}
          LINK3D_PROD_ENVS: ${{ secrets.LINK3D_PROD_ENVS }}
          TAPTRACK_STAGING_ENVS: ${{ secrets.TAPTRACK_STAGING_ENVS }}
          TAPTRACK_PROD_ENVS: ${{ secrets.TAPTRACK_PROD_ENVS }}
        run: |
          source ./scripts/parse-infrastructure-config.sh
          
          for server in ${{ steps.servers.outputs.servers }}; do
            echo "ðŸš€ Deploying to $server..."
            
            SSH_SECRET_NAME=$(get_ssh_secret "$server")
            SSH_HOST=$(get_ssh_host "$server")
            SSH_USER=$(get_ssh_user "$server")
            
            echo "ðŸ“¡ Connecting to $SSH_USER@$SSH_HOST using key from $SSH_SECRET_NAME..."
            
            # Get the SSH key from environment variable (secret name from config)
            SSH_KEY="${!SSH_SECRET_NAME}"
            
            if [ -z "$SSH_KEY" ]; then
              echo "âŒ Error: SSH key $SSH_SECRET_NAME not found in secrets"
              continue
            fi
            
            # Setup SSH key
            mkdir -p ~/.ssh
            echo "$SSH_KEY" > ~/.ssh/deploy_key
            chmod 600 ~/.ssh/deploy_key
            
            # Get env var secret name
            ENV_SECRET_NAME="$(echo $REPO_NAME | tr '[:lower:]' '[:upper:]' | tr '-' '_')_$(echo $ENVIRONMENT | tr '[:lower:]' '[:upper:]')_ENVS"
            ENV_CONTENT="${!ENV_SECRET_NAME}"
            
            # Deploy via SSH
            ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no "$SSH_USER@$SSH_HOST" bash -s << EOF
              set -e
              cd ~/infrastructure || cd /opt/infrastructure || cd /var/infrastructure
              
              # Pull latest infrastructure
              git pull origin main || true
              
              # Pull latest repo
              if [ -d "repos/$REPO_NAME" ]; then
                cd repos/$REPO_NAME
                git fetch origin
                git checkout $BRANCH || git checkout main || git checkout master
                git pull origin $BRANCH || git pull origin main || git pull origin master
                cd ../..
              else
                echo "Warning: Repo $REPO_NAME not found. Run setup-infrastructure first."
                exit 1
              fi
              
              # Write env file
              mkdir -p secrets
              printf '%s\n' "$ENV_CONTENT" > "secrets/${REPO_NAME}-${ENVIRONMENT}.env"
              
              # Recreate container
              SERVICE_NAME="${REPO_NAME}-${ENVIRONMENT}"
              docker-compose up -d --build \$SERVICE_NAME || docker-compose up -d \$SERVICE_NAME
              
              echo "âœ… Deployed \$SERVICE_NAME on $server"
            EOF
            
            # Cleanup SSH key
            rm -f ~/.ssh/deploy_key
            
          done
