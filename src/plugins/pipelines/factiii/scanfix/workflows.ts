/**
 * Workflow-related fixes for Factiii Pipeline plugin
 * Handles GitHub workflow generation, validation, and cleanup
 */

import * as fs from 'fs';
import * as path from 'path';
import { execSync } from 'child_process';
import type { FactiiiConfig, Fix } from '../../../../types/index.js';
import { generateWorkflows as generateWorkflowsUtil } from '../utils/workflows.js';
import { getFactiiiVersion } from '../../../../utils/version-check.js';

/**
 * Generate start.sh content based on compose file found in the project
 */
function generateStartSh(rootDir: string): string {
  // Detect which compose file exists
  let composeFile = 'docker-compose.yml';
  if (fs.existsSync(path.join(rootDir, 'compose.yml'))) {
    composeFile = 'compose.yml';
  }

  return '#!/bin/bash\n' +
    '# Generated by @factiii/stack\n' +
    '# Starts Docker containers for CI and local development\n' +
    '\n' +
    'set -e\n' +
    '\n' +
    'docker compose -f ' + composeFile + ' up -d\n';
}

export const workflowFixes: Fix[] = [
  {
    id: 'missing-workflows',
    stage: 'dev',
    severity: 'warning',
    description: 'üîÑ GitHub workflows not generated',
    scan: async (_config: FactiiiConfig, rootDir: string): Promise<boolean> => {
      const workflowsDir = path.join(rootDir, '.github', 'workflows');
      return !fs.existsSync(path.join(workflowsDir, 'stack-ci.yml'));
    },
    fix: async (_config: FactiiiConfig, rootDir: string): Promise<boolean> => {
      await generateWorkflowsUtil(rootDir);
      return true;
    },
    manualFix: 'Run: npx stack fix (will generate workflow files)',
  },
  {
    id: 'outdated-workflows',
    stage: 'dev',
    severity: 'info',
    description: 'üîÑ GitHub workflows may be outdated',
    scan: async (_config: FactiiiConfig, rootDir: string): Promise<boolean> => {
      const workflowPath = path.join(
        rootDir,
        '.github',
        'workflows',
        'stack-ci.yml'
      );
      if (!fs.existsSync(workflowPath)) return false;

      const content = fs.readFileSync(workflowPath, 'utf8');

      // Check if using old bloated workflow (has inline bash logic not from template)
      if (content.includes('docker compose build')) return true;

      // Check version comment
      const currentVersion = getFactiiiVersion();

      const versionMatch = content.match(/# Generated by @factiii\/stack v([\d.]+)/);
      if (!versionMatch) return true; // No version comment = outdated

      const workflowVersion = versionMatch[1];
      return workflowVersion !== currentVersion;
    },
    fix: async (_config: FactiiiConfig, rootDir: string): Promise<boolean> => {
      await generateWorkflowsUtil(rootDir);
      return true;
    },
    manualFix: 'Run: npx stack fix (will regenerate thin workflows)',
  },
  {
    id: 'orphaned-workflows',
    stage: 'dev',
    severity: 'warning',
    description: 'üóëÔ∏è Old workflow files found that are not generated by current version',
    scan: async (_config: FactiiiConfig, rootDir: string): Promise<boolean> => {
      const workflowsDir = path.join(rootDir, '.github', 'workflows');
      if (!fs.existsSync(workflowsDir)) return false;

      // List of workflows we currently generate (CI testing only)
      const validWorkflows = [
        'stack-ci.yml',
        'stack-cicd-prod.yml',
      ];

      // Find all stack-*.yml and factiii-*.yml files (clean up legacy too)
      const files = fs.readdirSync(workflowsDir);
      const managedFiles = files.filter(
        (f) => (f.startsWith('stack-') || f.startsWith('factiii-')) && f.endsWith('.yml')
      );

      // Check for orphaned files
      const orphaned = managedFiles.filter((f) => !validWorkflows.includes(f));

      return orphaned.length > 0;
    },
    fix: async (_config: FactiiiConfig, rootDir: string): Promise<boolean> => {
      const workflowsDir = path.join(rootDir, '.github', 'workflows');

      const validWorkflows = [
        'stack-ci.yml',
        'stack-cicd-prod.yml',
      ];

      const files = fs.readdirSync(workflowsDir);
      const managedFiles = files.filter(
        (f) => (f.startsWith('stack-') || f.startsWith('factiii-')) && f.endsWith('.yml')
      );
      const orphaned = managedFiles.filter((f) => !validWorkflows.includes(f));

      for (const file of orphaned) {
        const filePath = path.join(workflowsDir, file);
        fs.unlinkSync(filePath);
        console.log(`   üóëÔ∏è  Deleted orphaned workflow: ${file}`);
      }

      return orphaned.length > 0;
    },
    manualFix: 'Run: npx stack fix (will remove old workflow files)',
  },
  {
    id: 'workflows-uncommitted',
    stage: 'dev',
    severity: 'critical',
    description: 'üìå GitHub workflows not committed to git',
    scan: async (_config: FactiiiConfig, rootDir: string): Promise<boolean> => {
      const workflowsDir = path.join(rootDir, '.github', 'workflows');
      if (!fs.existsSync(workflowsDir)) return false;

      try {
        // Check git status for workflow files
        const status = execSync('git status --porcelain .github/workflows/', {
          cwd: rootDir,
          encoding: 'utf8',
          stdio: ['pipe', 'pipe', 'ignore'],
        });

        // If there's any output, workflows are uncommitted or untracked
        return status.trim().length > 0;
      } catch {
        // Not a git repo or git not available
        return false;
      }
    },
    fix: null, // Cannot auto-commit
    manualFix:
      'Commit and push workflow files to git:\n' +
      '      git add .github/workflows/\n' +
      '      git commit -m "Update stack workflows"\n' +
      '      git push',
  },
  {
    id: 'missing-start-sh',
    stage: 'dev',
    severity: 'warning',
    description: 'üê≥ start.sh not found (used by CI workflows to start Docker containers)',
    scan: async (_config: FactiiiConfig, rootDir: string): Promise<boolean> => {
      // Only check if a compose file exists (start.sh wraps docker compose)
      const hasCompose =
        fs.existsSync(path.join(rootDir, 'docker-compose.yml')) ||
        fs.existsSync(path.join(rootDir, 'compose.yml'));
      if (!hasCompose) return false;

      return !fs.existsSync(path.join(rootDir, 'start.sh'));
    },
    fix: async (_config: FactiiiConfig, rootDir: string): Promise<boolean> => {
      const content = generateStartSh(rootDir);
      const startPath = path.join(rootDir, 'start.sh');
      fs.writeFileSync(startPath, content, 'utf8');
      try {
        fs.chmodSync(startPath, 0o755);
      } catch {
        // Windows doesn't support chmod
      }
      console.log('   Created start.sh');
      return true;
    },
    manualFix:
      'Create start.sh in your project root:\n' +
      '      #!/bin/bash\n' +
      '      set -e\n' +
      '      docker compose -f docker-compose.yml up -d',
  },
];

