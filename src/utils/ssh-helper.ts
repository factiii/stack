/**
 * SSH Helper Utility
 *
 * Shared SSH execution logic for pipeline and server plugins.
 * Provides a consistent way to execute commands on remote servers.
 *
 * Supports environment-specific deploy keys only:
 * - ~/.ssh/staging_deploy_key, ~/.ssh/prod_deploy_key, ~/.ssh/mac_deploy_key
 * - Generated by: npx stack secrets write-ssh-keys
 */
import { execSync, spawnSync } from 'child_process';
import * as os from 'os';
import * as path from 'path';
import * as fs from 'fs';

import type { EnvironmentConfig, FactiiiConfig, Stage } from '../types/index.js';
import { extractEnvironments, getStageFromEnvironment } from './config-helpers.js';

/**
 * Map of stage names to their environment-specific SSH key filenames.
 * These keys are extracted from Ansible Vault by `npx stack secrets write-ssh-keys`.
 */
const STAGE_KEY_MAP: Record<string, string[]> = {
  staging: ['staging_deploy_key'],
  prod: ['prod_deploy_key'],
  mac: ['mac_deploy_key'],
};

/**
 * Find the SSH key path for a given stage.
 * Only returns stage-specific deploy keys — no generic key fallback.
 *
 * @param stage - The deployment stage (staging, prod, mac)
 * @returns Absolute path to SSH key, or null if none found
 */
export function findSshKeyForStage(stage: string): string | null {
  const sshDir = path.join(os.homedir(), '.ssh');

  const stageKeys = STAGE_KEY_MAP[stage] ?? [];
  for (const keyName of stageKeys) {
    const keyPath = path.join(sshDir, keyName);
    if (fs.existsSync(keyPath)) {
      return keyPath;
    }
  }

  return null;
}

/**
 * Get the EnvironmentConfig for a given stage from factiii.yml config.
 * Returns the first environment matching the stage.
 *
 * @param stage - The deployment stage (staging, prod)
 * @param config - Parsed factiii.yml config
 * @returns EnvironmentConfig with domain and ssh_user, or null
 */
export function getEnvConfigForStage(
  stage: Stage,
  config: FactiiiConfig
): EnvironmentConfig | null {
  const environments = extractEnvironments(config);

  for (const [envName, envConfig] of Object.entries(environments)) {
    try {
      if (getStageFromEnvironment(envName) === stage) {
        return envConfig;
      }
    } catch {
      continue;
    }
  }

  return null;
}

/**
 * Execute a Factiii CLI command on a remote server via direct SSH.
 * Used by scan.ts, fix.ts, and deployStage() when canReach returns via: 'ssh'.
 *
 * @param stage - Target stage (staging, prod)
 * @param config - Parsed factiii.yml config
 * @param command - The factiii CLI command to run (e.g., 'scan --staging', 'fix --prod')
 * @returns Object with success, stdout, and stderr
 */
export function sshRemoteFactiiiCommand(
  stage: Stage,
  config: FactiiiConfig,
  command: string
): { success: boolean; stdout: string; stderr: string } {
  const envConfig = getEnvConfigForStage(stage, config);
  if (!envConfig) {
    return {
      success: false,
      stdout: '',
      stderr: 'No environment config found for stage: ' + stage,
    };
  }

  const host = envConfig.domain;
  const user = envConfig.ssh_user ?? 'root';
  const keyPath = findSshKeyForStage(stage);

  if (!keyPath) {
    return {
      success: false,
      stdout: '',
      stderr: 'No SSH key found at ' + path.join(os.homedir(), '.ssh', stage + '_deploy_key') + '. Run: npx stack secrets write-ssh-keys',
    };
  }

  if (!host) {
    return {
      success: false,
      stdout: '',
      stderr: 'No domain configured for stage: ' + stage + '. Check factiii.yml environments.',
    };
  }

  // Build the remote command
  // Run inside the factiii repo directory on the server
  // $HOME is expanded by the remote shell, supporting non-root users
  const repoName = config.name || 'app';
  const remoteCommand = 'export PATH="/usr/local/bin:/opt/homebrew/bin:$PATH" && export FACTIII_ON_SERVER=true && cd $HOME/.factiii/' + repoName + ' && npx stack ' + command;

  console.log('   SSH: ' + user + '@' + host + ' → npx stack ' + command);
  console.log('   Connecting to ' + host + '... (timeout: 10min)');

  const startTime = Date.now();

  const result = spawnSync('ssh', [
    '-i', keyPath,
    '-o', 'StrictHostKeyChecking=no',
    '-o', 'ConnectTimeout=10',
    '-o', 'ServerAliveInterval=60',
    '-o', 'ServerAliveCountMax=5',
    user + '@' + host,
    remoteCommand,
  ], {
    encoding: 'utf8',
    stdio: ['pipe', 'pipe', 'pipe'],
    timeout: 600000, // 10 minute timeout for long-running operations
  });

  const elapsed = Math.floor((Date.now() - startTime) / 1000);
  console.log('   SSH completed in ' + elapsed + 's');

  // Print output in real-time style
  if (result.stdout) {
    process.stdout.write(result.stdout);
  }
  if (result.stderr) {
    process.stderr.write(result.stderr);
  }

  return {
    success: result.status === 0,
    stdout: result.stdout ?? '',
    stderr: result.stderr ?? '',
  };
}

/**
 * Execute a command on a remote server via SSH
 * @param envConfig - Environment config with host and ssh_user
 * @param command - Command to execute
 * @param stage - Optional stage to use the correct SSH key (staging, prod)
 * @returns Command output
 */
export async function sshExec(
  envConfig: EnvironmentConfig,
  command: string,
  stage?: Stage
): Promise<string> {
  // ============================================================
  // CRITICAL: Detect if we're already on the server
  // ============================================================
  // When GITHUB_ACTIONS=true or FACTIII_ON_SERVER=true, we're executing
  // on the server itself. Run commands locally instead of trying to SSH.
  // ============================================================
  if (process.env.GITHUB_ACTIONS === 'true' || process.env.FACTIII_ON_SERVER === 'true') {
    // We're already on the server - run command locally
    const result = execSync(command, { encoding: 'utf8', stdio: 'pipe' });
    return result.trim();
  }

  // Running from dev machine - SSH to server
  const host = envConfig.domain;
  const user = envConfig.ssh_user ?? 'ubuntu';

  // Use stage-specific key if stage is provided
  let keyPath: string | null = null;
  if (stage) {
    keyPath = findSshKeyForStage(stage);
  }

  // Fallback: try all known deploy keys
  if (!keyPath) {
    const keyPaths = [
      path.join(os.homedir(), '.ssh', 'staging_deploy_key'),
      path.join(os.homedir(), '.ssh', 'prod_deploy_key'),
      path.join(os.homedir(), '.ssh', 'mac_deploy_key'),
    ];

    for (const kp of keyPaths) {
      if (fs.existsSync(kp)) {
        keyPath = kp;
        break;
      }
    }
  }

  if (!keyPath) {
    throw new Error(
      'No SSH key found. Add a deploy key to ~/.ssh/ or run: npx stack secrets write-ssh-keys'
    );
  }

  const result = execSync(
    'ssh -i ' + keyPath +
    ' -o StrictHostKeyChecking=no' +
    ' -o ConnectTimeout=10' +
    ' -o ServerAliveInterval=60' +
    ' -o ServerAliveCountMax=5' +
    ' ' + user + '@' + host +
    ' "' + command.replace(/"/g, '\\"') + '"',
    { encoding: 'utf8', stdio: 'pipe' }
  );

  return result.trim();
}
