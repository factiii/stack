/**
 * Generate factiiiAuto.yml
 *
 * Generates the factiiiAuto.yml configuration file with auto-detected values.
 */

import * as fs from 'fs';
import * as path from 'path';
import yaml from 'js-yaml';

interface DetectedConfig {
  has_prisma?: boolean;
  has_trpc?: boolean;
  prisma_schema?: string;
  prisma_version?: string;
  dockerfile?: string;
  package_manager?: string;
  node_version?: string;
  pnpm_version?: string;
  aws_cli_installed?: boolean;
  [key: string]: unknown;
}

interface PluginWithDetect {
  id?: string;
  detectConfig?: (rootDir: string) => Promise<DetectedConfig>;
}

interface GenerateAutoOptions {
  plugins?: PluginWithDetect[];
}

/**
 * Get Factiii package version
 */
function getFactiiiVersion(): string {
  try {
    const packageJsonPath = path.join(__dirname, '../../package.json');
    const pkg = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8')) as { version?: string };
    return pkg.version ?? '1.0.0';
  } catch {
    return '1.0.0';
  }
}

/**
 * Load all plugins
 */
function loadAllPlugins(): PluginWithDetect[] {
  const plugins: PluginWithDetect[] = [];

  // Load pipeline plugins
  try {
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const FactiiiPipeline = require('../plugins/pipelines/factiii') as PluginWithDetect;
    plugins.push(FactiiiPipeline);
  } catch {
    // Plugin not available
  }

  // Load server plugins
  try {
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const MacMiniPlugin = require('../plugins/servers/mac-mini') as PluginWithDetect;
    plugins.push(MacMiniPlugin);
  } catch {
    // Plugin not available
  }

  try {
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const AWSPlugin = require('../plugins/servers/aws') as PluginWithDetect;
    plugins.push(AWSPlugin);
  } catch {
    // Plugin not available
  }

  // Load framework plugins
  try {
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const PrismaTrpcPlugin = require('../plugins/frameworks/prisma-trpc') as PluginWithDetect;
    plugins.push(PrismaTrpcPlugin);
  } catch {
    // Plugin not available
  }

  return plugins;
}

/**
 * Generate factiiiAuto.yml with auto-detected values from plugins
 */
export async function generateFactiiiAuto(
  rootDir: string,
  options: GenerateAutoOptions = {}
): Promise<void> {
  const outputPath = path.join(rootDir, 'factiiiAuto.yml');

  console.log('üîç Auto-detecting project configuration...\n');

  // Use provided plugins or load all
  const plugins = options.plugins ?? loadAllPlugins();
  const autoConfig: Record<string, unknown> = {
    factiii_version: getFactiiiVersion(),
    factiii_min_version: getFactiiiVersion(),
  };

  // Collect auto-detected config from each plugin
  for (const PluginClass of plugins) {
    if (PluginClass.detectConfig) {
      try {
        const detected = await PluginClass.detectConfig(rootDir);
        if (detected) {
          Object.assign(autoConfig, detected);

          // Log what was detected
          if (PluginClass.id === 'prisma-trpc' && detected.has_prisma) {
            console.log(`   ‚úÖ Prisma detected`);
            if (detected.prisma_schema) console.log(`      Schema: ${detected.prisma_schema}`);
            if (detected.prisma_version) console.log(`      Version: ${detected.prisma_version}`);
          }
          if (PluginClass.id === 'prisma-trpc' && detected.has_trpc) {
            console.log(`   ‚úÖ tRPC detected`);
          }
          if (PluginClass.id === 'factiii' && detected.dockerfile) {
            console.log(`   ‚úÖ Dockerfile: ${detected.dockerfile}`);
          }
          if (PluginClass.id === 'factiii' && detected.package_manager) {
            console.log(`   üì¶ Package manager: ${detected.package_manager}`);
          }
          if (PluginClass.id === 'factiii' && detected.node_version) {
            console.log(`   üì¶ Node version: ${detected.node_version}`);
          }
          if (PluginClass.id === 'factiii' && detected.pnpm_version) {
            console.log(`   üì¶ pnpm version: ${detected.pnpm_version}`);
          }
          if (PluginClass.id === 'aws' && detected.aws_cli_installed) {
            console.log(`   ‚úÖ AWS CLI installed`);
          }
        }
      } catch (e) {
        const errorMessage = e instanceof Error ? e.message : String(e);
        console.log(`   ‚ö†Ô∏è  Error detecting ${PluginClass.id}: ${errorMessage}`);
      }
    }
  }

  // Convert to YAML with comments
  const content = yaml.dump(autoConfig, {
    lineWidth: -1,
    noRefs: true,
  });

  // Add header comments
  const header = [
    '# Auto-detected configuration',
    '# Generated by: npx factiii',
    '# To override values, add: value OVERRIDE newvalue',
    '',
  ].join('\n');

  const finalContent = header + content;

  // Check if file exists and content changed
  const exists = fs.existsSync(outputPath);
  if (exists) {
    const existingContent = fs.readFileSync(outputPath, 'utf8');
    if (existingContent === finalContent) {
      console.log('\n‚è≠Ô∏è  factiiiAuto.yml unchanged');
      return;
    }
  }

  // Write file
  fs.writeFileSync(outputPath, finalContent);

  if (exists) {
    console.log('\nüîÑ Updated factiiiAuto.yml');
  } else {
    console.log('\n‚úÖ Created factiiiAuto.yml');
  }
}

