const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');
const { execSync } = require('child_process');

/**
 * Get current Factiii package version
 */
function getFactiiiVersion() {
  try {
    const packageJsonPath = path.join(__dirname, '../../package.json');
    const pkg = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
    return pkg.version || '1.0.0';
  } catch (e) {
    return '1.0.0';
  }
}

/**
 * Get latest version from npm registry
 */
async function getLatestVersion() {
  try {
    const result = execSync('npm view @factiii/stack version 2>/dev/null', {
      encoding: 'utf8',
      stdio: 'pipe'
    }).trim();
    return result || null;
  } catch (e) {
    return null;
  }
}

/**
 * Parse semantic version
 */
function parseVersion(version) {
  const match = version.match(/^(\d+)\.(\d+)\.(\d+)/);
  if (!match) return null;
  return {
    major: parseInt(match[1], 10),
    minor: parseInt(match[2], 10),
    patch: parseInt(match[3], 10)
  };
}

/**
 * Compare versions: returns -1, 0, or 1
 */
function compareVersions(a, b) {
  const vA = parseVersion(a);
  const vB = parseVersion(b);
  
  if (!vA || !vB) return 0;
  
  if (vA.major !== vB.major) return vA.major - vB.major;
  if (vA.minor !== vB.minor) return vA.minor - vB.minor;
  return vA.patch - vB.patch;
}

/**
 * Check if upgrade is breaking (major version change)
 */
function isBreakingUpgrade(from, to) {
  const vFrom = parseVersion(from);
  const vTo = parseVersion(to);
  
  if (!vFrom || !vTo) return false;
  return vTo.major > vFrom.major;
}

/**
 * Read factiiiAuto.yml version info
 */
function readFactiiiAutoVersion(rootDir) {
  const factiiiAutoPath = path.join(rootDir, 'factiiiAuto.yml');
  
  if (!fs.existsSync(factiiiAutoPath)) {
    return { factiii_version: null, factiii_min_version: null };
  }
  
  try {
    const content = fs.readFileSync(factiiiAutoPath, 'utf8');
    const config = yaml.load(content);
    return {
      factiii_version: config.factiii_version || null,
      factiii_min_version: config.factiii_min_version || null
    };
  } catch (e) {
    return { factiii_version: null, factiii_min_version: null };
  }
}

/**
 * Upgrade command
 */
async function upgrade(options = {}) {
  const rootDir = process.cwd();
  const currentVersion = getFactiiiVersion();
  const factiiiAutoVersion = readFactiiiAutoVersion(rootDir);
  
  console.log('‚ïê'.repeat(70));
  console.log('üîÑ Factiii Stack Upgrade Check');
  console.log('‚ïê'.repeat(70));
  console.log('');
  
  // Show current versions
  console.log('üìä Version Information:\n');
  console.log(`   Installed Factiii version: ${currentVersion}`);
  
  if (factiiiAutoVersion.factiii_version) {
    console.log(`   factiiiAuto.yml generated by: ${factiiiAutoVersion.factiii_version}`);
    
    if (compareVersions(currentVersion, factiiiAutoVersion.factiii_version) !== 0) {
      console.log(`   ‚ö†Ô∏è  Version mismatch detected`);
    } else {
      console.log(`   ‚úÖ Versions match`);
    }
  } else {
    console.log(`   factiiiAuto.yml: No version info (legacy file)`);
  }
  
  console.log('');
  
  // Check for updates
  if (options.check) {
    console.log('üîç Checking for updates...\n');
    
    const latestVersion = await getLatestVersion();
    
    if (latestVersion) {
      console.log(`   Latest version on npm: ${latestVersion}`);
      
      const comparison = compareVersions(latestVersion, currentVersion);
      
      if (comparison > 0) {
        console.log(`   üì¶ Update available: ${currentVersion} ‚Üí ${latestVersion}`);
        
        if (isBreakingUpgrade(currentVersion, latestVersion)) {
          console.log(`   ‚ö†Ô∏è  This is a MAJOR version upgrade`);
          console.log(`      Check CHANGELOG.md for breaking changes`);
        }
        
        console.log('');
        console.log('   To upgrade:');
        console.log('   npm update @factiii/stack');
        console.log('   npx factiii upgrade');
      } else {
        console.log(`   ‚úÖ You have the latest version`);
      }
    } else {
      console.log('   ‚ö†Ô∏è  Could not check npm registry');
      console.log('      (Package may not be published yet)');
    }
    
    console.log('');
    return;
  }
  
  // Perform upgrade (regenerate configs)
  console.log('üîß Regenerating configurations...\n');
  
  // Check if factiiiAuto.yml needs update
  const needsRegeneration = !factiiiAutoVersion.factiii_version || 
    compareVersions(currentVersion, factiiiAutoVersion.factiii_version) !== 0;
  
  if (needsRegeneration) {
    console.log('   Regenerating factiiiAuto.yml...');
    
    try {
      const { generateCoreAuto } = require('../generators/generate-factiii-auto');
      generateCoreAuto(rootDir);
      console.log('   ‚úÖ factiiiAuto.yml updated\n');
    } catch (e) {
      console.error(`   ‚ùå Failed to regenerate factiiiAuto.yml: ${e.message}\n`);
    }
  } else {
    console.log('   ‚úÖ factiiiAuto.yml is up to date\n');
  }
  
  // Regenerate workflows
  console.log('   Regenerating workflows...');
  
  try {
    const generateWorkflows = require('./generate-workflows');
    generateWorkflows({ output: '.github/workflows' });
  } catch (e) {
    console.error(`   ‚ùå Failed to regenerate workflows: ${e.message}\n`);
  }
  
  console.log('');
  console.log('‚ïê'.repeat(70));
  console.log('‚úÖ Upgrade Complete');
  console.log('‚ïê'.repeat(70));
  console.log('');
  console.log('üìã Next steps:');
  console.log('   1. Review changes: git diff');
  console.log('   2. Commit: git add -A && git commit -m "Upgrade Factiii to ' + currentVersion + '"');
  console.log('   3. Run: npx factiii (to verify)');
  console.log('');
}

module.exports = upgrade;

