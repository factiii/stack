# Repository Setup Requirements

Each repository (factiii, chop-shop, link3d, tap-track, etc.) needs the following to work with infrastructure.

> **NEW: Centralized Deployment**
> With the centralized approach, repos only need a Dockerfile and a simple trigger workflow.
> All configuration lives in the infrastructure repo. See **[QUICK_START.md](QUICK_START.md)**.

## Required Files

```
your-repo/
├── apps/
│   └── server/
│       ├── Dockerfile          # Required: Docker build file
│       └── .env.example        # Recommended: Template for environment variables
├── .env.example                 # Optional: Can be at root or in apps/server/
└── .github/
    └── workflows/
        └── trigger-infrastructure.yml  # Required: Triggers infrastructure deployment
```

## Dockerfile Requirements

- Location: `apps/server/Dockerfile` (or adjust in docker-compose.yml)
- Must expose a `/health` endpoint for health checks
- Should listen on port specified in docker-compose.yml (default: 5001)

**Port assignments:**
- factiii: 3001
- chop-shop: 5001
- link3d: 3003
- tap-track: 3005

## GitHub Workflow (Trigger Infrastructure)

Each repo needs a simple workflow that triggers the infrastructure repo when code is pushed.

Create `.github/workflows/trigger-infrastructure.yml`:

```yaml
name: Trigger Infrastructure Deploy

on:
  push:
    branches: [main, production]

jobs:
  trigger-infrastructure:
    runs-on: ubuntu-latest
    steps:
      - name: Trigger Infrastructure Deployment
        uses: peter-evans/repository-dispatch@v2
        with:
          token: ${{ secrets.INFRASTRUCTURE_DISPATCH_TOKEN }}
          repository: YOUR-ORG/infrastructure  # Update with your infrastructure repo
          event-type: repo-updated
          client-payload: |
            {
              "repo_name": "${{ github.event.repository.name }}",
              "branch": "${{ github.ref_name }}",
              "environment": "${{ github.ref_name == 'production' && 'prod' || 'staging' }}",
              "commit_sha": "${{ github.sha }}"
            }
```

**Required Secret in Repo:**
- `INFRASTRUCTURE_DISPATCH_TOKEN` - Personal Access Token with `repo` scope

**To create the token:**
1. Go to GitHub → Settings → Developer settings → Personal access tokens → Tokens (classic)
2. Generate new token with `repo` scope (allows triggering workflows in other repos)
3. Copy token and add as `INFRASTRUCTURE_DISPATCH_TOKEN` secret in the app repo

## Infrastructure Configuration Names

When adding a repo to infrastructure, use these naming conventions:

**Repository directory:**
- `repos/<repo-name>/`

**Environment files (generated by infrastructure):**
- `secrets/<repo-name>-staging.env`
- `secrets/<repo-name>-prod.env`

**Docker Compose services:**
- `<repo-name>-staging`
- `<repo-name>-prod`

**Container names:**
- `<repo-name>-staging`
- `<repo-name>-prod`

**Nginx server names:**
- Staging: `staging-<repo-name>.greasemoto.com`
- Production: `<repo-name>.greasemoto.com`
- Special case: chop-shop uses `staging-api.greasemoto.com` and `api.greasemoto.com`

## Adding Repo to Infrastructure

### Option A: Using GitHub Actions (Recommended)

1. Go to infrastructure repo → Actions → "Add Repo to Infrastructure"
2. Click "Run workflow"
3. Enter:
   - Repository name (e.g., `my-new-repo`)
   - Git URL (e.g., `https://github.com/user/my-new-repo.git`)
   - Server name (e.g., `mac_mini`)
   - Environment (`staging` or `prod`)
4. Click "Run workflow"

### Option B: Manual Setup

1. **Update infrastructure-config.yml:**
   ```yaml
   servers:
     mac_mini:
       repos:
         - name: my-new-repo
           environment: staging
           domain_override: null  # Or custom domain
   ```

2. **Add secrets to infrastructure repo:**
   - `MYNEWREPO_STAGING_ENVS` - Environment variables for staging
   - `MYNEWREPO_PROD_ENVS` - Environment variables for production

3. **Add service to docker-compose.yml:**
   ```yaml
   my-new-repo-staging:
     build:
       context: ./repos/my-new-repo
       dockerfile: apps/server/Dockerfile
     container_name: my-new-repo-staging
     environment:
       - NODE_ENV=staging
     env_file:
       - ./secrets/my-new-repo-staging.env
     networks:
       - infrastructure_network
     restart: unless-stopped
     depends_on:
       postgres-staging:
         condition: service_healthy
     healthcheck:
       test: ["CMD", "curl", "-f", "http://localhost:5001/health"]
       interval: 30s
       timeout: 10s
       retries: 3
       start_period: 40s
   ```

4. **Update nginx config:**
   Run `./scripts/generate-nginx-config.sh` to regenerate nginx.conf from infrastructure-config.yml.

5. **Update certbot domains:**
   Run `./scripts/generate-certbot-domains.sh` to get the domain list for certbot.

## Environment Variables

Environment variables are stored in **infrastructure repo** GitHub Secrets:

**Naming convention:**
- `<REPO_NAME>_STAGING_ENVS` - Staging environment variables
- `<REPO_NAME>_PROD_ENVS` - Production environment variables

**Format:** Newline-separated `key=value` pairs
```
NODE_ENV=staging
PORT=5001
DATABASE_URL=postgresql://postgres:postgres@postgres-staging:5432/myrepo_staging
CLIENT_APP_URL=https://staging-myrepo.greasemoto.com
```

**Note:** Production secrets MUST be stored as secrets (not variables) since they contain sensitive data.

## Summary Checklist

### In the Application Repo:
- [ ] Repo has `apps/server/Dockerfile`
- [ ] Repo has `.env.example` (recommended, for reference)
- [ ] Repo has `.github/workflows/trigger-infrastructure.yml`
- [ ] `INFRASTRUCTURE_DISPATCH_TOKEN` secret is configured

### In the Infrastructure Repo:
- [ ] Repo added to `infrastructure-config.yml`
- [ ] Environment secrets added: `<REPO>_STAGING_ENVS`, `<REPO>_PROD_ENVS`
- [ ] Services added to `docker-compose.yml`
- [ ] Nginx config regenerated (or will be auto-generated on deploy)
- [ ] Certbot domains updated

## Deployment Flow

1. Developer pushes to `main` branch in app repo
2. App repo workflow triggers infrastructure via `repository_dispatch`
3. Infrastructure repo receives webhook
4. Infrastructure reads `infrastructure-config.yml` to find target servers
5. Infrastructure SSHs to each server and:
   - Pulls latest infrastructure repo
   - Pulls latest app repo
   - Writes env file from GitHub Secrets
   - Runs `docker-compose up -d <repo>-<env>`
6. Container is rebuilt and restarted

## Next Steps

- See **[QUICK_START.md](QUICK_START.md)** for complete centralized setup guide
- See **[INITIAL_SETUP.md](INITIAL_SETUP.md)** for manual server setup
- See **[README.md](README.md)** for full documentation
